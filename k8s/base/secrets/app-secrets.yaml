# CostWatch Application Secrets Template
# DO NOT commit actual secrets to version control!
#
# Usage:
# 1. Copy this file: cp app-secrets.yaml app-secrets-actual.yaml
# 2. Replace <BASE64_ENCODED_VALUE> with actual base64-encoded secrets
# 3. Apply: kubectl apply -f app-secrets-actual.yaml
# 4. Add app-secrets-actual.yaml to .gitignore
#
# To base64 encode a value:
# echo -n "your-secret-value" | base64
#
# To decode and verify:
# echo "encoded-value" | base64 -d

apiVersion: v1
kind: Secret
metadata:
  name: costwatch-secrets
  namespace: costwatch
  labels:
    app: costwatch
    component: secrets
type: Opaque
data:
  # Database Credentials
  # Format: postgresql://username:password@host:port/database
  DATABASE_URL: <BASE64_ENCODED_VALUE>
  DATABASE_PASSWORD: <BASE64_ENCODED_VALUE>

  # JWT Secret for authentication tokens
  # Generate with: openssl rand -base64 32
  JWT_SECRET_KEY: <BASE64_ENCODED_VALUE>

  # AWS Credentials (if not using IAM roles)
  # Prefer IAM roles (IRSA) over static credentials in production
  AWS_ACCESS_KEY_ID: <BASE64_ENCODED_VALUE>
  AWS_SECRET_ACCESS_KEY: <BASE64_ENCODED_VALUE>

  # Redis Connection
  REDIS_URL: <BASE64_ENCODED_VALUE>
  REDIS_PASSWORD: <BASE64_ENCODED_VALUE>

  # Email Service Credentials (for alerts)
  SMTP_HOST: <BASE64_ENCODED_VALUE>
  SMTP_PORT: <BASE64_ENCODED_VALUE>
  SMTP_USERNAME: <BASE64_ENCODED_VALUE>
  SMTP_PASSWORD: <BASE64_ENCODED_VALUE>
  SMTP_FROM_EMAIL: <BASE64_ENCODED_VALUE>

  # Slack Webhook (for notifications)
  SLACK_WEBHOOK_URL: <BASE64_ENCODED_VALUE>

  # SNS Topic ARN (for AWS notifications)
  SNS_TOPIC_ARN: <BASE64_ENCODED_VALUE>

  # API Keys for external services
  CLOUDWATCH_API_KEY: <BASE64_ENCODED_VALUE>

---
# Example using AWS Secrets Manager (recommended for production)
# Requires External Secrets Operator or similar
apiVersion: v1
kind: Secret
metadata:
  name: costwatch-secrets-example-asm
  namespace: costwatch
  annotations:
    # Example annotation for AWS Secrets Manager integration
    aws-secrets-manager/secret-name: "costwatch/production/secrets"
    aws-secrets-manager/region: "us-west-2"
type: Opaque
# Data will be populated by External Secrets Operator

---
# Secret for pulling private Docker images (if needed)
apiVersion: v1
kind: Secret
metadata:
  name: costwatch-registry-secret
  namespace: costwatch
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: <BASE64_ENCODED_DOCKER_CONFIG>
# Generate with:
# kubectl create secret docker-registry costwatch-registry-secret \
#   --docker-server=<registry-url> \
#   --docker-username=<username> \
#   --docker-password=<password> \
#   --docker-email=<email> \
#   --dry-run=client -o yaml

---
# TLS Certificate Secret (for HTTPS)
apiVersion: v1
kind: Secret
metadata:
  name: costwatch-tls
  namespace: costwatch
  labels:
    app: costwatch
type: kubernetes.io/tls
data:
  tls.crt: <BASE64_ENCODED_CERTIFICATE>
  tls.key: <BASE64_ENCODED_PRIVATE_KEY>
# Generate with cert-manager or:
# kubectl create secret tls costwatch-tls \
#   --cert=path/to/tls.crt \
#   --key=path/to/tls.key \
#   --dry-run=client -o yaml

---
# SECURITY BEST PRACTICES:
#
# 1. Never commit actual secrets to version control
# 2. Use separate secrets per environment (dev/staging/prod)
# 3. Rotate secrets regularly (every 90 days minimum)
# 4. Use AWS Secrets Manager, HashiCorp Vault, or External Secrets Operator for production
# 5. Enable encryption at rest for Kubernetes secrets
# 6. Use RBAC to limit secret access to specific service accounts
# 7. Audit secret access with Kubernetes audit logs
# 8. Consider using sealed-secrets or SOPS for GitOps workflows
#
# IRSA (IAM Roles for Service Accounts):
# Preferred over static AWS credentials. Configure via:
# - Create IAM role with required policies
# - Annotate service account: eks.amazonaws.com/role-arn
# - Remove AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY from secrets
#
# External Secrets Operator:
# Sync secrets from external secret management systems
# - AWS Secrets Manager
# - HashiCorp Vault
# - Azure Key Vault
# - GCP Secret Manager
